import os
from base64 import b64decode
from enum import StrEnum
from typing import TypedDict

from .ejson import loads
from .scram_impl import CryptoDatum, TNScramClient


class APIKeyAuthMech(StrEnum):
    AUTO = 'AUTO'  # autodetect and try SCRAM if available
    SCRAM = 'SCRAM'  # only attempt SCRAM auth
    PLAIN = 'PLAIN'  # only attempt PLAIN auth


class ScramAuthData(TypedDict, total=False):
    raw_key: str
    """ raw API key material. This is API key as returned when generated by server. """
    client_key: str
    """ base64-encoded data containing client_key. This may have been returned by
    TrueNAS server, or may be pre-computed client-side. Not required if raw_key
    was supplied. """
    stored_key: str
    """ base64-encoded data containing stored_key. This may have been returned by
    TrueNAS server, or may be pre-computed client-side. Not required if raw_key
    was supplied. """
    server_key: str
    """ base64-encoded data containing server_key. This may have been returned by
    TrueNAS server, or may be pre-computed client-side. Not required if raw_key
    was supplied. """
    api_key_id: int
    """ datastore id of the API key. This is not required when raw_key was provided """


def get_key_material(key: str) -> ScramAuthData:
    """ User may have provided a string containing key info or path to key file.
    In the case of the key file, we assume it is JSON-formatted with above fields. """
    if os.path.isabs(key):
        # User has provided path to a key let's read the material
        with open(key, 'r') as f:
            key = f.read().strip()

    if '-' not in key:
        return ScramAuthData(**loads(key))

    return ScramAuthData(raw_key=key)


def api_key_authenticate(
    c,
    auth_mechanism: APIKeyAuthMech,
    username: str,
    key_in: str | None
) -> None:
    """
    Perform API key authentication on an already-existing middleware
    session.

    Arguments:
        c: truenas_api_client.Client() instance
        auth_mechanism: one of 'AUTO', 'SCRAM', or 'PLAIN'
        key: either the actual key material or an absolute path to a file
        in which it's located

    Returns:
        None

    Raises:
        ValueError:
            API key is not valid for server / user
    """
    auth_data = get_key_material(key_in)
    do_legacy_auth = False

    try:
        available_mechanisms = c.call('auth.mechanism_choices')
    except Exception as exc:
        if 'Method does not exist' in str(exc):
            # We have an older version of TrueNAS. Minimally, API key authentication of some sort should be available
            available_mechanisms = ['API_KEY_PLAIN']

    match auth_mechanism:
        case APIKeyAuthMech.PLAIN:
            do_legacy_auth = True
        case APIKeyAuthMech.AUTO:
            if 'SCRAM' not in available_mechanisms or not username:
                do_legacy_auth = True
        case APIKeyAuthMech.SCRAM:
            if 'SCRAM' not in available_mechanisms:
                raise ValueError('API_KEY_SCRAM authentication is not supported on the remote server')

            if not username:
                raise ValueError('username is required for API_KEY_SCRAM authentication')

    if do_legacy_auth and not auth_data.get('raw_key'):
        raise ValueError('Raw API key is required in order to do legacy API key authentication')

    if do_legacy_auth:
        if not c.call('auth.login_with_key', auth_data['raw_key']):
            raise ValueError('Invalid API key')

        return

    # We may have pre-computed keys for server-side or be dealing with raw API
    # key. pre-computed keys are useful to avoid having to do potentially expensive
    # computations client-side.
    if auth_data.get('raw_key'):
        api_key_id, raw_key = auth_data['raw_key'].split('-', 1)
        sc = TNScramClient(raw_key_material=raw_key, api_key_id=int(api_key_id))
    else:
        for key in ('server_key', 'stored_key', 'client_key'):
            if not auth_data.get(key):
                raise ValueError(f'{key}: required key is absent from: {key_in}')

        client_datum = CryptoDatum(b64decode(auth_data['client_key']))
        stored_datum = CryptoDatum(b64decode(auth_data['stored_key']))
        server_datum = CryptoDatum(b64decode(auth_data['server_key']))
        sc = TNScramClient(
            client_key=client_datum,
            stored_key=stored_datum,
            server_key=server_datum,
            api_key_id=auth_data.get('api_key_id', 0)
        )

    client_first_message = sc.get_client_first_message(username)

    # Send our first client SCRAM message that provides client nonce to server and provides what key identifier
    # is being used server-side.
    resp = c.call('auth.login_ex', {'mechanism': 'SCRAM'} | client_first_message)
    resp_type = resp.pop('response_type')

    if resp_type != 'SCRAM_RESPONSE':
        raise ValueError(f'{resp_type}: unexpected server respones')

    client_final_message = sc.get_client_final_message(server_resp_dict=resp)

    # Send our first client SCRAM final message that provides client proof to server
    resp = c.call('auth.login_ex', {'mechanism': 'SCRAM'} | client_final_message)
    resp_type = resp.pop('response_type')

    if resp_type == 'AUTH_ERR':
        raise ValueError('Failed to authenticate with API key')

    if resp_type != 'SCRAM_RESPONSE':
        raise ValueError(f'{resp_type}: unexpected server respones')

    # Now validate that the server final message is OK
    try:
        sc.verify_server_final_message(server_resp_dict=resp)
    except Exception as e:
        c.call('auth.logout')
        raise ValueError(f'Remote server validation failed! {e}')
