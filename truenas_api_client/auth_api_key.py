import os
import re
from base64 import b64decode
from configparser import ConfigParser, Error as ConfigParserError
from dataclasses import dataclass
from enum import StrEnum
from json import JSONDecodeError
from typing import TYPE_CHECKING, TypedDict

from .ejson import loads
from .scram_impl import CryptoDatum, TNScramClient

if TYPE_CHECKING:
    from . import Client

# Raw API keys have the format: {api_key_id}-{raw_key_material}
# Example: 1-uz8DhKHFhRIUQIvjzabPYtpy5wf1DJ3ZBLlDgNVhRAFT7Y6pJGUlm0n3apwxWEU4
RAW_KEY_SEPARATOR = '-'
RAW_KEY_PATTERN = re.compile(r'^\d+-[a-zA-Z0-9]+$')

# Authentication mechanism constants
MECHANISM_SCRAM = 'SCRAM'
MECHANISM_API_KEY_PLAIN = 'API_KEY_PLAIN'
RESPONSE_TYPE_SCRAM = 'SCRAM_RESPONSE'
RESPONSE_TYPE_AUTH_ERR = 'AUTH_ERR'


class APIKeyAuthMech(StrEnum):
    AUTO = 'AUTO'  # autodetect and try SCRAM if available
    SCRAM = 'SCRAM'  # only attempt SCRAM auth
    PLAIN = 'PLAIN'  # only attempt PLAIN auth


class KeyDataType(StrEnum):
    RAW = 'RAW'
    PRECOMPUTED = 'PRECOMPUTED'


class RawKeyData(TypedDict):
    """Raw API key material as returned when generated by server."""
    raw_key: str


class PrecomputedKeyData(TypedDict):
    """Pre-computed cryptographic keys for SCRAM authentication.

    These may have been returned by TrueNAS server or pre-computed client-side.
    Avoids expensive PBKDF2 computation on the client.
    All fields are required.
    """
    client_key: str
    stored_key: str
    server_key: str
    api_key_id: int


@dataclass
class KeyData:
    """Wrapper object to help type checking."""
    key_data_type: KeyDataType
    key_data: RawKeyData | PrecomputedKeyData


def _parse_ini_config(key: str) -> dict[str, str | int]:
    """Parse INI-formatted key data into a dictionary.

    Args:
        key: INI-formatted string

    Returns:
        Dictionary with parsed configuration

    Raises:
        ConfigParserError: If INI parsing fails
        KeyError: If required section is missing
        ValueError: If type conversion fails
    """
    config = ConfigParser()
    config.read_string(key)

    # Convert ConfigParser to dict
    config_dict: dict[str, str | int]
    if len(config.sections()) == 0:
        # No section headers, try DEFAULT
        config_dict = dict(config['DEFAULT'])
    elif 'TRUENAS_API_KEY' in config:
        # Use TRUENAS_API_KEY section
        config_dict = dict(config['TRUENAS_API_KEY'])
    elif len(config.sections()) == 1:
        # Single section, use it
        config_dict = dict(config[config.sections()[0]])
    else:
        # Multiple sections without TRUENAS_API_KEY - error
        raise ValueError(
            f'Multiple sections found but [TRUENAS_API_KEY] not present. '
            f'Available sections: {config.sections()}'
        )

    # Convert string values to appropriate types
    if 'api_key_id' in config_dict:
        config_dict['api_key_id'] = int(config_dict['api_key_id'])

    return config_dict


def get_key_material(key: str) -> KeyData:
    """ User may have provided a string containing key info or path to key file.
    In the case of the key file, we assume it is JSON-formatted or INI-formatted with above fields. """
    if os.path.isabs(key):
        # User has provided path to a key file, read the material
        try:
            with open(key, 'r') as f:
                key = f.read().strip()
        except FileNotFoundError:
            raise ValueError(f'Key file not found: {key}')
        except PermissionError:
            raise ValueError(f'Permission denied reading key file: {key}')
        except OSError as e:
            raise ValueError(f'Error reading key file {key}: {e}')
    else:
        # Strip whitespace from input to ensure clean matching
        key = key.strip()

    # Check if it matches raw API key pattern: {digits}-{alphanumeric}
    # Example: 1-uz8DhKHFhRIUQIvjzabPYtpy5wf1DJ3ZBLlDgNVhRAFT7Y6pJGUlm0n3apwxWEU4
    if RAW_KEY_PATTERN.match(key):
        return KeyData(key_data_type=KeyDataType.RAW, key_data=RawKeyData(raw_key=key))

    # Try parsing as structured data (JSON or INI format)
    try:
        data = loads(key)
    except JSONDecodeError as json_err:
        try:
            data = _parse_ini_config(key)
        except (ConfigParserError, KeyError, ValueError) as ini_err:
            raise ValueError(
                f'Key material must be either a raw API key (format: <id>-<key>), '
                f'valid JSON, or valid INI/ConfigParser format. '
                f'JSON error: {json_err}. INI error: {ini_err}'
            ) from ini_err

    # Construct the appropriate type based on the fields present
    try:
        if 'raw_key' in data:
            raw_key_value = data['raw_key']
            if not isinstance(raw_key_value, str):
                raise ValueError(f'raw_key must be a string, got {type(raw_key_value)}')
            return KeyData(
                key_data_type=KeyDataType.RAW,
                key_data=RawKeyData(raw_key=raw_key_value)
            )
        else:
            # Validate and extract precomputed key fields with type checking
            client_key_value = data['client_key']
            stored_key_value = data['stored_key']
            server_key_value = data['server_key']
            api_key_id_value = data['api_key_id']

            if not isinstance(client_key_value, str):
                raise ValueError(f'client_key must be a string, got {type(client_key_value)}')
            if not isinstance(stored_key_value, str):
                raise ValueError(f'stored_key must be a string, got {type(stored_key_value)}')
            if not isinstance(server_key_value, str):
                raise ValueError(f'server_key must be a string, got {type(server_key_value)}')
            if not isinstance(api_key_id_value, int):
                raise ValueError(f'api_key_id must be an int, got {type(api_key_id_value)}')

            return KeyData(
                key_data_type=KeyDataType.PRECOMPUTED,
                key_data=PrecomputedKeyData(
                    client_key=client_key_value,
                    stored_key=stored_key_value,
                    server_key=server_key_value,
                    api_key_id=api_key_id_value
                )
            )
    except KeyError as e:
        raise ValueError(f'Missing required field in key data: {e}') from e


def api_key_authenticate(
    c: 'Client',
    auth_mechanism: APIKeyAuthMech,
    username: str,
    key_in: str | None
) -> None:
    """
    Perform API key authentication on an already-existing middleware
    session.

    Arguments:
        c: truenas_api_client.Client() instance
        auth_mechanism: one of 'AUTO', 'SCRAM', or 'PLAIN'
        username: name of the user that the API key is associated with (required for SCRAM)
        key_in: either the actual key material or an absolute path to a file
            in which it's located

    Returns:
        None

    Raises:
        ValueError:
            API key is not valid for server / user
    """
    if key_in is None:
        raise ValueError('API key is required')

    auth_data = get_key_material(key_in)
    do_legacy_auth = False

    try:
        available_mechanisms = c.call('auth.mechanism_choices')
    except Exception as exc:
        if 'Method does not exist' in str(exc):
            # We have an older version of TrueNAS. Minimally, API key authentication of some sort should be available
            available_mechanisms = [MECHANISM_API_KEY_PLAIN]
        else:
            raise

    match auth_mechanism:
        case APIKeyAuthMech.PLAIN:
            do_legacy_auth = True
        case APIKeyAuthMech.AUTO:
            if MECHANISM_SCRAM not in available_mechanisms or not username:
                do_legacy_auth = True
        case APIKeyAuthMech.SCRAM:
            if MECHANISM_SCRAM not in available_mechanisms:
                raise ValueError('SCRAM authentication is not supported on the remote server')

            if not username:
                raise ValueError('username is required for SCRAM authentication')

    if do_legacy_auth and auth_data.key_data_type != KeyDataType.RAW:
        raise ValueError('Raw API key is required in order to do legacy API key authentication')

    if do_legacy_auth:
        # Type narrowing: key_data is RawKeyData here
        assert auth_data.key_data_type == KeyDataType.RAW
        legacy_key_data: RawKeyData = auth_data.key_data  # type: ignore[assignment]
        if not c.call('auth.login_with_api_key', legacy_key_data['raw_key']):
            raise ValueError('Invalid API key')

        return

    # We may have pre-computed keys for server-side or be dealing with raw API
    # key. pre-computed keys are useful to avoid having to do potentially expensive
    # computations client-side.
    if auth_data.key_data_type == KeyDataType.RAW:
        # Type narrowing: key_data is RawKeyData here
        raw_key_data: RawKeyData = auth_data.key_data  # type: ignore[assignment]
        api_key_id, raw_key = raw_key_data['raw_key'].split(RAW_KEY_SEPARATOR, 1)
        sc = TNScramClient(raw_key_material=raw_key, api_key_id=int(api_key_id))
    else:
        # Type narrowing: key_data is PrecomputedKeyData here
        precomputed_data: PrecomputedKeyData = auth_data.key_data  # type: ignore[assignment]
        client_datum = CryptoDatum(b64decode(precomputed_data['client_key']))
        stored_datum = CryptoDatum(b64decode(precomputed_data['stored_key']))
        server_datum = CryptoDatum(b64decode(precomputed_data['server_key']))
        sc = TNScramClient(
            client_key=client_datum,
            stored_key=stored_datum,
            server_key=server_datum,
            api_key_id=precomputed_data['api_key_id']
        )

    client_first_message = sc.get_client_first_message(username)

    # Send our first client SCRAM message that provides client nonce to server and provides what key identifier
    # is being used server-side.
    resp = c.call('auth.login_ex', {'mechanism': MECHANISM_SCRAM} | client_first_message)
    resp_type = resp.pop('response_type')

    if resp_type != RESPONSE_TYPE_SCRAM:
        raise ValueError(f'{resp_type}: unexpected server response')

    client_final_message = sc.get_client_final_message(server_resp_dict=resp)

    # Send our client SCRAM final message that provides client proof to server
    resp = c.call('auth.login_ex', {'mechanism': MECHANISM_SCRAM} | client_final_message)
    resp_type = resp.pop('response_type')

    if resp_type == RESPONSE_TYPE_AUTH_ERR:
        raise ValueError('Failed to authenticate with API key')

    if resp_type != RESPONSE_TYPE_SCRAM:
        raise ValueError(f'{resp_type}: unexpected server response')

    # Now validate that the server final message is OK
    try:
        sc.verify_server_final_message(server_resp_dict=resp)
    except Exception as e:
        # Attempt to logout, but don't mask the original verification error
        try:
            c.call('auth.logout')
        except Exception:
            pass  # Ignore logout errors, the verification failure is more critical
        raise ValueError(f'Remote server validation failed! {e}')
